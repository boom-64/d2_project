"""Schemas for general objects."""

from __future__ import annotations

# ==== Standard Libraries ====
import hashlib
import logging
from dataclasses import dataclass
from typing import TYPE_CHECKING
from urllib.parse import urljoin, urlparse

# ==== Non-Standard Libraries ====
import validators

# ==== Local Libraries ====
import d2_project.core.validators as d2_project_validators

# ==== Type Checking ====

if TYPE_CHECKING:
    from pathlib import Path
    from urllib.parse import ParseResult

# ==== Logging Config ====
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)

_logger = logging.getLogger(__name__)

# ==== Classes ====


@dataclass(frozen=True)
class MD5Checksum:
    """Custom class for MD5 checksums.

    Attributes:
        val (str): Checksum value.
        from_calc (bool): Whether class instance was generated by from_calc
            class method.

    """

    val: str
    from_calc: bool = False

    # ==== Initialisation and Validation ====

    def __post_init__(self) -> None:
        """Post-initialisation code.

        This post-initialisation code validates the checksum value and sets the
        value to all lowercase.
        """
        lc_val = self.val.lower()

        if not self.from_calc:
            d2_project_validators.str_matches_pattern(
                value=lc_val,
                pattern=d2_project_validators.lc_checksum_pattern.pattern,
                pattern_for=d2_project_validators.lc_checksum_pattern.pattern_for,
            )

        object.__setattr__(self, "val", lc_val)

    # ==== Public Methods ====

    @classmethod
    def calc(cls, path: Path) -> MD5Checksum:
        """Calculate the MD5 hash of the given file.

        Args:
            path (Path): Path to the file.

        Returns:
            MD5Checksum: The hexadecimal MD5 hash of the file contents.

        Raises:
            TypeError: If 'path' type is not Path.
            ValueError: If 'path' does not refer to a file.

        """
        d2_project_validators.entry_is_file(path)
        # Assign 'hasher' - an MD5 hash object. Using MD5 for file integrity
        # verification only (not cryptographic security).
        hasher = hashlib.md5()  # noqa: S324

        with path.open("rb") as f:
            # Update 'hasher' with each 8KB chunk
            for chunk in iter(lambda: f.read(8192), b""):
                hasher.update(chunk)

        # Return 'hexdigest()' of 'hasher' MD5 hash object
        return cls(hasher.hexdigest(), from_calc=True)

    # ==== Custom Exceptions ====

    class MismatchError(Exception):
        """Custom exception for checksum mismatches.

        This exception is raised when a calculated checksum does not match
        the expected checksum. It includes both the expected and actual
        checksums.

        Attributes/args:
            expected (core.schemas.MD5Checksum): Expected checksum.
            computed (core.schemas.MD5Checksum): Actual checksum calculated.
        """

        expected: MD5Checksum
        computed: MD5Checksum

        def __init__(
            self,
            *,
            expected: MD5Checksum,
            computed: MD5Checksum,
        ) -> None:
            """Initialise class."""
            self.expected = expected
            self.computed = computed

            super().__init__(
                f"Checksum mismatch: expected {self.expected.val}, got "
                f"{self.computed.val}.",
            )


@dataclass(frozen=True)
class ParsedURL:
    """Represents a URL with its base URL and path components.

    This class parses the provided URL into its base URL and path
    components. It also allows reconstruction of the full URL from these
    components.

    Attributes:
        url (str): The full URL, including the base URL and path.
        base_url (str): The base URL, consisting of the scheme (e.g.,
            'https') and netloc (e.g., 'example.com').
        path (str): The path component of the URL. Defaults to an empty
            string if not provided.

    Methods:
        from_full_url(full_url: str) -> 'URL':
            Creates a URL instance from a full URL string.

        from_base_and_path(base_url: str, path: str) -> 'URL':
            Creates a URL instance from a base URL and a path.

    Raises:
        TypeError: If any argument types are incorrect.
        ValueError: If the reconstructed URL is valid according to the
            'validators.url()' check.

    """

    url: str
    base_url: str
    path: str

    # ==== Public Methods ====

    @classmethod
    def from_full_url(cls, full_url: str) -> ParsedURL:
        """Create a URL instance by parsing a full URL string.

        Args:
            full_url (str): The full URL to parse and validate.

        Returns:
            ParsedURL: An instance of the URL class with parsed components.

        Raises:
            ValueError: If the passed full_url is not a valid URL according
                to validators.url().

        """
        full_url = full_url.strip().rstrip("/")

        if not validators.url(full_url):
            _logger.exception("Passed URL '%s' is an invalid URL.", full_url)
            raise ValueError

        parsed_url: ParseResult = urlparse(full_url)

        computed_base_url: str = f"{parsed_url.scheme}://{parsed_url.netloc}"
        computed_path: str = parsed_url.path.strip("/")

        return cls(
            url=full_url,
            base_url=computed_base_url,
            path=computed_path,
        )

    @classmethod
    def from_base_and_path(cls, *, base_url: str, path: str) -> ParsedURL:
        """Create a URL instance from a base URL and a path.

        Args:
            base_url (str): The base URL, including scheme and netloc.
            path (str): The path component to append to the base URL.

        Returns:
            URL: An instance of the URL class with the combined URL.

        Raises:
            ValueError: If the reconstructed URL is invalid according to
                validators.url().

        """
        cleaned_base_url = base_url.strip().rstrip("/")
        cleaned_path = path.strip().strip("/")

        computed_url = urljoin(cleaned_base_url + "/", cleaned_path)

        parsed_url: ParseResult = urlparse(computed_url)
        full_path = parsed_url.path

        if not validators.url(computed_url):
            _logger.exception(
                "Passed URL '%s' is an invalid URL.",
                computed_url,
            )
            raise ValueError

        return cls(url=computed_url, base_url=cleaned_base_url, path=full_path)
